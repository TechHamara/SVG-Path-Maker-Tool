<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SVG Path Maker Tool</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        :root {
            --bg-color: #f5f5f5;
            --text-color: #333;
            --surface-color: #fff;
            --border-color: #ccc;
            --hover-color: #3e8e41;
            --success-color: #45a049;
            --error-color: #f44336;
            transition: all 0.3s ease;
        }

        [data-theme="dark"] {
            --bg-color: #1a1a1a;
            --text-color: #fff;
            --surface-color: #2d2d2d;
            --border-color: #404040;
            --hover-color: #2d7a30;
            --success-color: #388e3c;
            --error-color: #d32f2f;
        }

        body {
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        .container {
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            margin: 0 auto;
            gap: 20px;
        }
        .title {
            text-align: center;
            color: var(--text-color);
            margin-bottom: 10px;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .controls button {
            padding: 8px 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .controls button:hover {
            background-color: var(--hover-color);
        }
        .workspace {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .code-editor {
            flex: 1;
            min-width: 300px;
        }
        .preview {
            flex: 1;
            min-width: 300px;
            background-color: var(--surface-color);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
            border: 1px solid var(--border-color);
            position: relative;
            touch-action: none; /* Prevent default touch behaviors */
        }
        #code-area {
            width: 100%;
            height: 400px;
            padding: 10px;
            font-family: monospace;
            resize: vertical;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--surface-color);
            color: var(--text-color);
        }
        #svg-preview {
            width: 100%;
            height: 400px;
            border: 1px dashed var(--border-color);
            background-color: var(--surface-color);
            overflow: hidden;
            cursor: grab;
        }
        #svg-preview.dragging {
            cursor: grabbing;
        }
        .point-handle {
            cursor: move;
            touch-action: none;
        }
        .control-point {
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        .control-point:hover {
            opacity: 1;
        }
        .preview-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            z-index: 1;
        }
        .preview-controls button {
            padding: 4px 8px;
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-color);
            cursor: pointer;
            font-size: 12px;
        }
        .output-container {
            margin-top: 20px;
            padding: 10px;
            background-color: var(--surface-color);
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
            border: 1px solid var(--border-color);
        }
        #svg-output {
            width: 100%;
            min-height: 100px;
            border: 1px solid #eee;
            padding: 10px;
            font-family: monospace;
            margin-top: 10px;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 4px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border-radius: 50%;
        }
        .copy-btn {
            padding: 4px 8px;
            font-size: 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .copy-btn:hover {
            background-color: #45a049;
        }
        .copy-btn:active {
            transform: scale(0.95);
        }
        .copy-btn.success {
            background-color: #45a049;
            animation: flash 0.5s ease;
        }
        .copy-btn.error {
            background-color: #f44336;
            animation: shake 0.5s ease;
        }
        @keyframes flash {
            0% { background-color: #4CAF50; }
            50% { background-color: #45a049; }
            100% { background-color: #4CAF50; }
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 60px;
            height: 30px;
            border-radius: 15px;
            background-color: var(--surface-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            padding: 5px;
            border: 2px solid var(--border-color);
            transition: all 0.3s ease;
            z-index: 1000; /* Ensure toggle stays on top */
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
            user-select: none; /* Prevent text selection */
        }

        .theme-toggle::before {
            content: "üåû";
            position: absolute;
            left: 5px;
            font-size: 16px;
            pointer-events: none; /* Prevent icon from interfering with clicks */
        }

        .theme-toggle::after {
            content: "üåô";
            position: absolute;
            right: 5px;
            font-size: 16px;
            pointer-events: none; /* Prevent icon from interfering with clicks */
        }

        .theme-toggle-thumb {
            width: 26px;
            height: 26px;
            background-color: #4CAF50;
            border-radius: 50%;
            transform: translateX(0);
            transition: transform 0.3s ease;
        }

        [data-theme="dark"] .theme-toggle-thumb {
            transform: translateX(30px);
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .controls > div {
                margin-right: 0 !important;
            }
            
            .controls button {
                width: 100%;
                margin: 5px 0;
            }
            
            .workspace {
                flex-direction: column;
            }
            
            .code-editor, .preview {
                min-width: 100%;
            }
            
            #code-area {
                height: 300px;
            }
            
            #svg-preview {
                height: 300px;
            }
            
            .theme-toggle {
                top: 10px;
                right: 10px;
            }
            
            .title {
                font-size: 1.5em;
                margin-top: 40px;
            }
        }

        @media (min-width: 769px) and (max-width: 1024px) {
            .container {
                max-width: 90%;
            }
            
            .workspace {
                gap: 15px;
            }
            
            .code-editor, .preview {
                min-width: 48%;
            }
        }

        @media (min-width: 1025px) {
            .container {
                max-width: 1200px;
            }
            
            .workspace {
                gap: 20px;
            }
            
            .code-editor, .preview {
                min-width: 300px;
            }
        }

        /* Add viewport height adjustment for mobile */
        @media (max-height: 800px) {
            #code-area, #svg-preview {
                height: 250px;
            }
        }

        /* Adjust input field and generate button for mobile */
        @media (max-width: 480px) {
            #char-input {
                width: 60px !important;
            }
            
            .controls > div {
                flex-wrap: wrap;
                justify-content: center;
            }
            
            #generate-btn {
                width: 100%;
                margin-top: 10px;
                margin-left: 0 !important;
            }
        }

        .footer {
            margin-top: 40px;
            text-align: center;
            padding: 20px;
            color: var(--text-color);
            border-top: 1px solid var(--border-color);
        }

        .footer a {
            color: #4CAF50;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .footer a:hover {
            color: var(--hover-color);
        }

        @media (max-width: 768px) {
            .footer {
                margin-top: 20px;
                padding: 15px;
                font-size: 0.9em;
            }
        }

        .transform-handle {
            position: absolute;
            width: 20px;
            height: 20px;
            background: var(--surface-color);
            border: 2px solid #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            touch-action: none;
            z-index: 2;
        }

        .transform-handle.top-right {
            top: -10px;
            right: -10px;
            cursor: ne-resize;
        }

        .transform-handle.bottom-right {
            bottom: -10px;
            right: -10px;
            cursor: se-resize;
        }

        .transform-handle.bottom-left {
            bottom: -10px;
            left: -10px;
            cursor: sw-resize;
        }

        .transform-handle.top-left {
            top: -10px;
            left: -10px;
            cursor: nw-resize;
        }

        .path-element {
            position: relative;
        }

        .line-handle {
            stroke: #4CAF50;
            stroke-width: 2;
            cursor: move;
            touch-action: none;
        }

        .code-highlight {
            background-color: rgba(76, 175, 80, 0.1);
            transition: background-color 0.5s ease;
        }

        @keyframes highlight-fade {
            from { background-color: rgba(76, 175, 80, 0.2); }
            to { background-color: transparent; }
        }

        #code-area.highlight {
            animation: highlight-fade 1s ease;
        }
    </style>
</head>
<body>
    <div class="theme-toggle" id="theme-toggle">
        <div class="theme-toggle-thumb"></div>
    </div>
    <div class="container">
        <h1 class="title">SVG Path Maker Tool</h1>
        
        <div class="controls">
            <div style="display: flex; align-items: center; margin-right: 15px;">
                <label for="char-input" style="margin-right: 5px; font-weight: bold; color: var(--text-color);">Generate Path for:</label>
                <input type="text" 
                    id="char-input" 
                    maxlength="1" 
                    style="
                        width: 40px; 
                        padding: 6px; 
                        text-align: center; 
                        font-size: 16px;
                        border: 2px solid var(--border-color);
                        border-radius: 4px;
                        background-color: var(--surface-color);
                        color: var(--text-color);
                        transition: all 0.3s ease;
                        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
                    "
                    placeholder="A"
                    onmouseover="this.style.borderColor='#4CAF50'"
                    onmouseout="this.style.borderColor='var(--border-color)'"
                    onfocus="this.style.boxShadow='0 0 5px rgba(76,175,80,0.5)'">
                <button 
                    id="generate-btn" 
                    style="
                        margin-left: 10px;
                        padding: 8px 16px;
                        background-color: #4CAF50;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                        transition: all 0.3s ease;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                    "
                    onmouseover="this.style.backgroundColor='var(--hover-color)';this.style.transform='translateY(-1px)'"
                    onmouseout="this.style.backgroundColor='#4CAF50';this.style.transform='translateY(0)'">
                    Generate
                </button>
            </div>
            <button id="run-btn">Run & Preview</button>
            <button id="clear-btn">Clear</button>
            <button id="example-btn">Load Example</button>
        </div>
        
        <div class="workspace">
            <div class="code-editor">
                <h3 style="display: flex; align-items: center; gap: 10px;">
                    Path Code Editor
                    <button id="copy-code-btn" class="copy-btn">Copy</button>
                </h3>
                <textarea id="code-area" placeholder="Enter your path commands here..."></textarea>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #4CAF50;"></div>
                        <span>moveTo</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #2196F3;"></div>
                        <span>lineTo</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #FF9800;"></div>
                        <span>cubicTo</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #9C27B0;"></div>
                        <span>quadraticTo</span>
                    </div>
                </div>
            </div>
            
            <div class="preview">
                <h3>Visual Preview</h3>
                <div class="preview-controls">
                    <button id="reset-view">Reset View</button>
                    <button id="toggle-points">Toggle Points</button>
                </div>
                <div id="svg-preview"></div>
            </div>
        </div>
        
        <div class="output-container">
            <h3 style="display: flex; align-items: center; gap: 10px;">
                SVG Output
                <button id="copy-btn" class="copy-btn">Copy</button>
            </h3>
            <div id="svg-output"></div>
        </div>
    </div>
    
    <footer class="footer">
        <p>Created with ‚ù§Ô∏è by <a href="https://github.com/TechHamara" target="_blank">TechHamara</a> &copy; 2025</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const codeArea = document.getElementById('code-area');
            const runBtn = document.getElementById('run-btn');
            const clearBtn = document.getElementById('clear-btn');
            const exampleBtn = document.getElementById('example-btn');
            const generateBtn = document.getElementById('generate-btn');
            const charInput = document.getElementById('char-input');
            const svgPreview = document.getElementById('svg-preview');
            const svgOutput = document.getElementById('svg-output');
            const copyBtn = document.getElementById('copy-btn');
            const copyCodeBtn = document.getElementById('copy-code-btn');
            
            // SVG Path class to handle path operations
            class SVGPath {
                constructor() {
                    this.commands = [];
                    this.svgPath = '';
                }
                
                moveTo(x, y) {
                    this.commands.push({ cmd: 'M', params: [x, y], type: 'moveTo' });
                    return this;
                }
                
                lineTo(x, y) {
                    this.commands.push({ cmd: 'L', params: [x, y], type: 'lineTo' });
                    return this;
                }
                
                cubicTo(cx1, cy1, cx2, cy2, x, y) {
                    this.commands.push({ cmd: 'C', params: [cx1, cy1, cx2, cy2, x, y], type: 'cubicTo' });
                    return this;
                }
                
                quadraticTo(cx, cy, x, y) {
                    this.commands.push({ cmd: 'Q', params: [cx, cy, x, y], type: 'quadraticTo' });
                    return this;
                }
                
                close() {
                    this.commands.push({ cmd: 'Z', params: [], type: 'close' });
                    return this;
                }
                
                // Build SVG path string
                buildPath() {
                    this.svgPath = this.commands.map(cmd => {
                        if (cmd.cmd === 'Z') return 'Z';
                        return `${cmd.cmd}${cmd.params.join(',')}`;
                    }).join(' ');
                    return this.svgPath;
                }
                
                // Get points for visual representation
                getPoints() {
                    let points = [];
                    this.commands.forEach(cmd => {
                        if (cmd.cmd === 'M' || cmd.cmd === 'L') {
                            points.push({ 
                                x: cmd.params[0], 
                                y: cmd.params[1], 
                                type: cmd.type 
                            });
                        } else if (cmd.cmd === 'C') {
                            // Control points and end point for cubic bezier
                            points.push({ 
                                x: cmd.params[0], 
                                y: cmd.params[1], 
                                type: 'control', 
                                controlFor: 'cubic1' 
                            });
                            points.push({ 
                                x: cmd.params[2], 
                                y: cmd.params[3], 
                                type: 'control', 
                                controlFor: 'cubic2' 
                            });
                            points.push({ 
                                x: cmd.params[4], 
                                y: cmd.params[5], 
                                type: cmd.type 
                            });
                        } else if (cmd.cmd === 'Q') {
                            // Control point and end point for quadratic bezier
                            points.push({ 
                                x: cmd.params[0], 
                                y: cmd.params[1], 
                                type: 'control', 
                                controlFor: 'quadratic' 
                            });
                            points.push({ 
                                x: cmd.params[2], 
                                y: cmd.params[3], 
                                type: cmd.type 
                            });
                        }
                    });
                    return points;
                }
                
                clear() {
                    this.commands = [];
                    this.svgPath = '';
                    return this;
                }

                // Validate the path has valid commands
                validate() {
                    if (this.commands.length === 0) {
                        throw new Error('Path must have at least one command');
                    }
                    
                    // Check for invalid parameters
                    this.commands.forEach(cmd => {
                        if (cmd.params) {
                            cmd.params.forEach(param => {
                                if (typeof param !== 'number' || isNaN(param)) {
                                    throw new Error('Invalid parameter in path command: ' + param);
                                }
                            });
                        }
                    });
                    return true;
                }
            }
            
            // Execute the path code and update the preview
            function executeCode() {
                try {
                    // Clear the preview and error state
                    svgPreview.innerHTML = '';
                    svgOutput.textContent = '';
                    svgOutput.style.color = '#000';
                    
                    // Create SVG element
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', '100%');
                    svg.setAttribute('height', '100%');
                    svg.setAttribute('viewBox', '0 0 200 150');
                    svgPreview.appendChild(svg);
                    
                    // Create path object
                    const path = new SVGPath();
                    
                    // Safely execute the code by wrapping it in a Function
                    try {
                        const executePath = new Function('path', codeArea.value);
                        executePath(path);
                        path.validate(); // Validate the path after execution
                    } catch (codeError) {
                        svgOutput.style.color = '#f00';
                        throw new Error(`Invalid path commands: ${codeError.message}`);
                    }
                    
                    if (path.commands.length === 0) {
                        throw new Error('No path commands were generated');
                    }
                    
                    // Get the points for visual markers
                    const points = path.getPoints();
                    
                    // Create the SVG path element
                    const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const pathData = path.buildPath();
                    if (!pathData) {
                        throw new Error('Failed to generate path data');
                    }
                    pathElement.setAttribute('d', pathData);
                    pathElement.setAttribute('fill', '#e0e0e0');
                    pathElement.setAttribute('stroke', '#333');
                    pathElement.setAttribute('stroke-width', '1');
                    svg.appendChild(pathElement);
                    
                    // Clear any existing control point lines
                    const existingLines = svg.querySelectorAll('line');
                    existingLines.forEach(line => line.remove());
                    
                    // Add point markers
                    points.forEach(point => {
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', point.x);
                        circle.setAttribute('cy', point.y);
                        
                        // Different styles for different point types
                        if (point.type === 'control') {
                            circle.setAttribute('r', '2');
                            circle.setAttribute('fill', '#ff0000');
                            circle.setAttribute('opacity', '0.7');
                        } else {
                            circle.setAttribute('r', '3');
                            
                            // Color based on command type
                            let color = '#333';
                            if (point.type === 'moveTo') color = '#4CAF50';
                            else if (point.type === 'lineTo') color = '#2196F3';
                            else if (point.type === 'cubicTo') color = '#FF9800';
                            else if (point.type === 'quadraticTo') color = '#9C27B0';
                            
                            circle.setAttribute('fill', color);
                        }
                        
                        svg.appendChild(circle);
                    });
                    
                    // Add connecting lines for control points
                    let lastMovePoint = null;
                    let lastPoint = null;
                    
                    points.forEach((point, index) => {
                        if (point.type === 'moveTo') {
                            lastMovePoint = point;
                            lastPoint = point;
                        } else if (point.type === 'control') {
                            if (lastPoint) {
                                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                line.setAttribute('x1', lastPoint.x);
                                line.setAttribute('y1', lastPoint.y);
                                line.setAttribute('x2', point.x);
                                line.setAttribute('y2', point.y);
                                line.setAttribute('stroke', '#ff0000');
                                line.setAttribute('stroke-width', '0.5');
                                line.setAttribute('stroke-dasharray', '2,2');
                                svg.appendChild(line);
                            }
                        } else {
                            if (point.type === 'close' && lastMovePoint) {
                                lastPoint = lastMovePoint;
                            } else {
                                lastPoint = point;
                            }
                        }
                    });
                    
                    // Display the generated SVG path
                    svgOutput.textContent = path.buildPath();
                    
                } catch (error) {
                    // Display error
                    svgOutput.textContent = `Error: ${error.message}`;
                }
            }
            
            // Clear the editor and preview
            function clearAll() {
                codeArea.value = '';
                svgPreview.innerHTML = '';
                svgOutput.textContent = '';
            }
            
            // Load example code
            function loadExample() {
                codeArea.value = `// Left vertical bar
path.moveTo(45, 30);
path.cubicTo(55, 30, 65, 35, 65, 50);
path.lineTo(65, 100);
path.cubicTo(65, 115, 55, 120, 45, 120);
path.cubicTo(35, 120, 25, 115, 25, 100);
path.lineTo(25, 50);
path.cubicTo(25, 35, 35, 30, 45, 30);
path.close();

// Right vertical bar
path.moveTo(105, 30);
path.cubicTo(115, 30, 125, 35, 125, 50);
path.lineTo(125, 100);
path.cubicTo(125, 115, 115, 120, 105, 120);
path.cubicTo(95, 120, 85, 115, 85, 100);
path.lineTo(85, 50);
path.cubicTo(85, 35, 95, 30, 105, 30);
path.close();

// Middle connector with curved style
path.moveTo(65, 65);
path.cubicTo(65, 60, 70, 60, 75, 60);
path.lineTo(85, 60);
path.cubicTo(90, 60, 95, 60, 95, 65);
path.cubicTo(95, 70, 90, 75, 85, 75);
path.lineTo(75, 75);
path.cubicTo(70, 75, 65, 70, 65, 65);
path.close();`;
                
                executeCode();
            }
            
            // Letter/number path generator
            function generateCharacterPath(char) {
                // Get the character from input, default to 'H' if empty
                char = char && char.trim() !== '' ? char.toUpperCase() : 'H';
                
                // Clear the editor first
                codeArea.value = '';
                svgPreview.innerHTML = '';
                svgOutput.textContent = '';
                
                // Create path based on the character
                let pathCode = '';
                
                switch(char) {
                    case 'A':
                        pathCode = `// Left slant of A
path.moveTo(30, 120);
path.lineTo(65, 30);
path.cubicTo(68, 25, 72, 25, 75, 30);
path.lineTo(110, 120);
path.cubicTo(112, 125, 110, 130, 105, 130);
path.cubicTo(100, 130, 97, 125, 95, 120);
path.lineTo(85, 100);
path.lineTo(55, 100);
path.lineTo(45, 120);
path.cubicTo(43, 125, 40, 130, 35, 130);
path.cubicTo(30, 130, 28, 125, 30, 120);
path.close();

// Crossbar of A
path.moveTo(60, 80);
path.lineTo(80, 80);
path.cubicTo(85, 80, 85, 70, 80, 70);
path.lineTo(60, 70);
path.cubicTo(55, 70, 55, 80, 60, 80);
path.close();`;
                        break;
                    case 'B':
                        pathCode = `// Vertical of B
path.moveTo(30, 30);
path.cubicTo(35, 25, 40, 25, 45, 30);
path.lineTo(45, 120);
path.cubicTo(45, 125, 40, 130, 35, 130);
path.cubicTo(30, 130, 25, 125, 25, 120);
path.lineTo(25, 40);
path.cubicTo(25, 35, 28, 32, 30, 30);
path.close();

// Top curve of B
path.moveTo(45, 30);
path.lineTo(80, 30);
path.cubicTo(95, 30, 105, 40, 105, 55);
path.cubicTo(105, 70, 95, 80, 80, 80);
path.lineTo(45, 80);
path.cubicTo(40, 80, 40, 75, 45, 75);
path.lineTo(80, 75);
path.cubicTo(90, 75, 95, 67, 95, 55);
path.cubicTo(95, 43, 90, 35, 80, 35);
path.lineTo(45, 35);
path.close();

// Bottom curve of B
path.moveTo(45, 75);
path.lineTo(80, 75);
path.cubicTo(95, 75, 105, 85, 105, 100);
path.cubicTo(105, 115, 95, 125, 80, 125);
path.lineTo(45, 125);
path.cubicTo(40, 125, 40, 120, 45, 120);
path.lineTo(80, 120);
path.cubicTo(90, 120, 95, 112, 95, 100);
path.cubicTo(95, 88, 90, 80, 80, 80);
path.lineTo(45, 80);
path.close();`;
                        break;
                    case 'C':
                        pathCode = `// C curve
path.moveTo(100, 40);
path.cubicTo(90, 25, 75, 20, 60, 20);
path.cubicTo(40, 20, 20, 40, 20, 75);
path.cubicTo(20, 110, 40, 130, 60, 130);
path.cubicTo(75, 130, 90, 125, 100, 110);
path.cubicTo(103, 105, 100, 100, 95, 100);
path.cubicTo(92, 100, 90, 102, 88, 105);
path.cubicTo(82, 115, 72, 120, 60, 120);
path.cubicTo(45, 120, 30, 100, 30, 75);
path.cubicTo(30, 50, 45, 30, 60, 30);
path.cubicTo(72, 30, 82, 35, 88, 45);
path.cubicTo(90, 48, 92, 50, 95, 50);
path.cubicTo(100, 50, 103, 45, 100, 40);
path.close();`;
                        break;
                    case 'D':
                        pathCode = `// Vertical of D
path.moveTo(30, 30);
path.cubicTo(35, 25, 40, 25, 45, 30);
path.lineTo(45, 120);
path.cubicTo(45, 125, 40, 130, 35, 130);
path.cubicTo(30, 130, 25, 125, 25, 120);
path.lineTo(25, 40);
path.cubicTo(25, 35, 28, 32, 30, 30);
path.close();

// Curved body of D
path.moveTo(45, 30);
path.lineTo(80, 30);
path.cubicTo(100, 30, 115, 50, 115, 75);
path.cubicTo(115, 100, 100, 120, 80, 120);
path.lineTo(45, 120);
path.close();`;
                        break;
                    case 'E':
                        pathCode = `// Vertical of E
path.moveTo(30, 30);
path.cubicTo(35, 25, 40, 25, 45, 30);
path.lineTo(45, 120);
path.cubicTo(45, 125, 40, 130, 35, 130);
path.cubicTo(30, 130, 25, 125, 25, 120);
path.lineTo(25, 40);
path.cubicTo(25, 35, 28, 32, 30, 30);
path.close();

// Top bar of E
path.moveTo(45, 30);
path.lineTo(105, 30);
path.cubicTo(110, 30, 115, 35, 115, 40);
path.cubicTo(115, 45, 110, 50, 105, 50);
path.lineTo(45, 50);
path.close();

// Middle bar of E
path.moveTo(45, 70);
path.lineTo(95, 70);
path.cubicTo(100, 70, 105, 75, 105, 80);
path.cubicTo(105, 85, 100, 90, 95, 90);
path.lineTo(45, 90);
path.close();

// Bottom bar of E
path.moveTo(45, 110);
path.lineTo(105, 110);
path.cubicTo(110, 110, 115, 115, 115, 120);
path.cubicTo(115, 125, 110, 130, 105, 130);
path.lineTo(45, 130);
path.close();`;
                        break;
                    case 'F':
                        pathCode = `// Vertical of F
path.moveTo(30, 30);
path.cubicTo(35, 25, 40, 25, 45, 30);
path.lineTo(45, 120);
path.cubicTo(45, 125, 40, 130, 35, 130);
path.cubicTo(30, 130, 25, 125, 25, 120);
path.lineTo(25, 40);
path.cubicTo(25, 35, 28, 32, 30, 30);
path.close();

// Top bar of F
path.moveTo(45, 30);
path.lineTo(105, 30);
path.cubicTo(110, 30, 115, 35, 115, 40);
path.cubicTo(115, 45, 110, 50, 105, 50);
path.lineTo(45, 50);
path.close();

// Middle bar of F
path.moveTo(45, 70);
path.lineTo(95, 70);
path.cubicTo(100, 70, 105, 75, 105, 80);
path.cubicTo(105, 85, 100, 90, 95, 90);
path.lineTo(45, 90);
path.close();`;
                        break;
                    case 'G':
                        pathCode = `// G curve
path.moveTo(100, 40);
path.cubicTo(90, 25, 75, 20, 60, 20);
path.cubicTo(40, 20, 20, 40, 20, 75);
path.cubicTo(20, 110, 40, 130, 60, 130);
path.cubicTo(75, 130, 90, 125, 100, 110);
path.lineTo(100, 80);
path.lineTo(70, 80);
path.cubicTo(65, 80, 60, 75, 60, 70);
path.cubicTo(60, 65, 65, 60, 70, 60);
path.lineTo(110, 60);
path.cubicTo(115, 60, 120, 65, 120, 70);
path.lineTo(120, 110);
path.cubicTo(110, 125, 85, 140, 60, 140);
path.cubicTo(30, 140, 10, 110, 10, 75);
path.cubicTo(10, 40, 30, 10, 60, 10);
path.cubicTo(85, 10, 110, 25, 120, 50);
path.close();`;
                        break;
                    case 'H': // Default example (from original)
                        pathCode = `// Left vertical bar
path.moveTo(45, 30);
path.cubicTo(55, 30, 65, 35, 65, 50);
path.lineTo(65, 100);
path.cubicTo(65, 115, 55, 120, 45, 120);
path.cubicTo(35, 120, 25, 115, 25, 100);
path.lineTo(25, 50);
path.cubicTo(25, 35, 35, 30, 45, 30);
path.close();

// Right vertical bar
path.moveTo(105, 30);
path.cubicTo(115, 30, 125, 35, 125, 50);
path.lineTo(125, 100);
path.cubicTo(125, 115, 115, 120, 105, 120);
path.cubicTo(95, 120, 85, 115, 85, 100);
path.lineTo(85, 50);
path.cubicTo(85, 35, 95, 30, 105, 30);
path.close();

// Middle connector with curved style
path.moveTo(65, 65);
path.cubicTo(65, 60, 70, 60, 75, 60);
path.lineTo(85, 60);
path.cubicTo(90, 60, 95, 60, 95, 65);
path.cubicTo(95, 70, 90, 75, 85, 75);
path.lineTo(75, 75);
path.cubicTo(70, 75, 65, 70, 65, 65);
path.close();`;
                        break;
                    case 'I':
                        pathCode = `// Vertical of I
path.moveTo(70, 30);
path.cubicTo(75, 25, 80, 25, 85, 30);
path.lineTo(85, 120);
path.cubicTo(85, 125, 80, 130, 75, 130);
path.cubicTo(70, 130, 65, 125, 65, 120);
path.lineTo(65, 40);
path.cubicTo(65, 35, 68, 32, 70, 30);
path.close();

// Top bar of I
path.moveTo(45, 30);
path.lineTo(105, 30);
path.cubicTo(110, 30, 115, 35, 115, 40);
path.cubicTo(115, 45, 110, 50, 105, 50);
path.lineTo(45, 50);
path.cubicTo(40, 50, 35, 45, 35, 40);
path.cubicTo(35, 35, 40, 30, 45, 30);
path.close();

// Bottom bar of I
path.moveTo(45, 110);
path.lineTo(105, 110);
path.cubicTo(110, 110, 115, 115, 115, 120);
path.cubicTo(115, 125, 110, 130, 105, 130);
path.lineTo(45, 130);
path.cubicTo(40, 130, 35, 125, 35, 120);
path.cubicTo(35, 115, 40, 110, 45, 110);
path.close();`;
                        break;
                    case 'J':
                        pathCode = `// Hook of J
path.moveTo(90, 30);
path.lineTo(90, 100);
path.cubicTo(90, 120, 75, 130, 60, 130);
path.cubicTo(45, 130, 30, 120, 30, 100);
path.cubicTo(30, 95, 35, 90, 40, 90);
path.cubicTo(45, 90, 50, 95, 50, 100);
path.cubicTo(50, 110, 55, 115, 60, 115);
path.cubicTo(65, 115, 70, 110, 70, 100);
path.lineTo(70, 30);
path.cubicTo(70, 25, 75, 20, 80, 20);
path.cubicTo(85, 20, 90, 25, 90, 30);
path.close();

// Top bar of J
path.moveTo(50, 30);
path.lineTo(110, 30);
path.cubicTo(115, 30, 120, 35, 120, 40);
path.cubicTo(120, 45, 115, 50, 110, 50);
path.lineTo(50, 50);
path.cubicTo(45, 50, 40, 45, 40, 40);
path.cubicTo(40, 35, 45, 30, 50, 30);
path.close();`;
                        break;
                    case 'K':
                        pathCode = `// Vertical of K
path.moveTo(30, 30);
path.cubicTo(35, 25, 40, 25, 45, 30);
path.lineTo(45, 120);
path.cubicTo(45, 125, 40, 130, 35, 130);
path.cubicTo(30, 130, 25, 125, 25, 120);
path.lineTo(25, 40);
path.cubicTo(25, 35, 28, 32, 30, 30);
path.close();

// Upper diagonal of K
path.moveTo(45, 70);
path.lineTo(95, 30);
path.cubicTo(100, 25, 110, 25, 115, 30);
path.cubicTo(120, 35, 120, 45, 115, 50);
path.lineTo(65, 80);
path.close();

// Lower diagonal of K
path.moveTo(65, 80);
path.lineTo(115, 110);
path.cubicTo(120, 115, 120, 125, 115, 130);
path.cubicTo(110, 135, 100, 135, 95, 130);
path.lineTo(45, 90);
path.close();`;
                        break;
                    case 'L':
                        pathCode = `// Vertical of L
path.moveTo(30, 30);
path.cubicTo(35, 25, 40, 25, 45, 30);
path.lineTo(45, 120);
path.cubicTo(45, 125, 40, 130, 35, 130);
path.cubicTo(30, 130, 25, 125, 25, 120);
path.lineTo(25, 40);
path.cubicTo(25, 35, 28, 32, 30, 30);
path.close();

// Base of L
path.moveTo(45, 110);
path.lineTo(105, 110);
path.cubicTo(110, 110, 115, 115, 115, 120);
path.cubicTo(115, 125, 110, 130, 105, 130);
path.lineTo(45, 130);
path.close();`;
                        break;
                    case 'M':
                        pathCode = `// Left vertical of M
path.moveTo(20, 120);
path.lineTo(20, 40);
path.cubicTo(20, 30, 30, 25, 35, 30);
path.lineTo(75, 70);
path.lineTo(115, 30);
path.cubicTo(120, 25, 130, 30, 130, 40);
path.lineTo(130, 120);
path.cubicTo(130, 125, 125, 130, 120, 130);
path.cubicTo(115, 130, 110, 125, 110, 120);
path.lineTo(110, 60);
path.lineTo(75, 90);
path.lineTo(40, 60);
path.lineTo(40, 120);
path.cubicTo(40, 125, 35, 130, 30, 130);
path.cubicTo(25, 130, 20, 125, 20, 120);
path.close();`;
                        break;
                    case 'N':
                        pathCode = `// Left vertical of N
path.moveTo(30, 30);
path.cubicTo(35, 25, 40, 25, 45, 30);
path.lineTo(45, 120);
path.cubicTo(45, 125, 40, 130, 35, 130);
path.cubicTo(30, 130, 25, 125, 25, 120);
path.lineTo(25, 40);
path.cubicTo(25, 35, 28, 32, 30, 30);
path.close();

// Diagonal of N
path.moveTo(45, 120);
path.lineTo(105, 30);
path.cubicTo(110, 25, 115, 25, 120, 30);
path.lineTo(120, 120);
path.cubicTo(120, 125, 115, 130, 110, 130);
path.cubicTo(105, 130, 100, 125, 100, 120);
path.lineTo(100, 60);
path.lineTo(45, 120);
path.close();`;
                        break;
                    case 'O':
                        pathCode = `// O curve
path.moveTo(75, 20);
path.cubicTo(100, 20, 120, 45, 120, 75);
path.cubicTo(120, 105, 100, 130, 75, 130);
path.cubicTo(50, 130, 30, 105, 30, 75);
path.cubicTo(30, 45, 50, 20, 75, 20);
path.close();

// Inner O curve
path.moveTo(75, 35);
path.cubicTo(95, 35, 105, 55, 105, 75);
path.cubicTo(105, 95, 95, 115, 75, 115);
path.cubicTo(55, 115, 45, 95, 45, 75);
path.cubicTo(45, 55, 55, 35, 75, 35);
path.close();`;
                        break;
                    case 'P':
                        pathCode = `// Vertical of P
path.moveTo(30, 30);
path.cubicTo(35, 25, 40, 25, 45, 30);
path.lineTo(45, 120);
path.cubicTo(45, 125, 40, 130, 35, 130);
path.cubicTo(30, 130, 25, 125, 25, 120);
path.lineTo(25, 40);
path.cubicTo(25, 35, 28, 32, 30, 30);
path.close();

// Bowl of P
path.moveTo(45, 30);
path.lineTo(80, 30);
path.cubicTo(100, 30, 115, 45, 115, 65);
path.cubicTo(115, 85, 100, 100, 80, 100);
path.lineTo(45, 100);
path.close();`;
                        break;
                    case 'Q':
                        pathCode = `// Main circle of Q
path.moveTo(75, 20);
path.cubicTo(100, 20, 120, 45, 120, 75);
path.cubicTo(120, 105, 100, 130, 75, 130);
path.cubicTo(50, 130, 30, 105, 30, 75);
path.cubicTo(30, 45, 50, 20, 75, 20);
path.close();

// Inner circle of Q
path.moveTo(75, 35);
path.cubicTo(95, 35, 105, 55, 105, 75);
path.cubicTo(105, 95, 95, 115, 75, 115);
path.cubicTo(55, 115, 45, 95, 45, 75);
path.cubicTo(45, 55, 55, 35, 75, 35);
path.close();

// Tail of Q
path.moveTo(85, 95);
path.lineTo(120, 130);
path.cubicTo(125, 135, 130, 135, 135, 130);
path.cubicTo(140, 125, 140, 120, 135, 115);
path.lineTo(100, 80);
path.close();`;
                        break;
                    case 'R':
                        pathCode = `// Vertical of R
path.moveTo(30, 30);
path.cubicTo(35, 25, 40, 25, 45, 30);
path.lineTo(45, 120);
path.cubicTo(45, 125, 40, 130, 35, 130);
path.cubicTo(30, 130, 25, 125, 25, 120);
path.lineTo(25, 40);
path.cubicTo(25, 35, 28, 32, 30, 30);
path.close();

// Bowl of R
path.moveTo(45, 30);
path.lineTo(80, 30);
path.cubicTo(100, 30, 115, 45, 115, 65);
path.cubicTo(115, 85, 100, 100, 80, 100);
path.lineTo(45, 100);
path.close();

// Leg of R
path.moveTo(75, 85);
path.lineTo(120, 120);
path.cubicTo(125, 125, 125, 135, 120, 140);
path.cubicTo(115, 145, 105, 145, 100, 140);
path.lineTo(65, 100);
path.close();`;
                        break;
                    case 'S':
                        pathCode = `// S curve
path.moveTo(100, 45);
path.cubicTo(100, 25, 85, 20, 70, 20);
path.cubicTo(55, 20, 40, 25, 40, 45);
path.cubicTo(40, 65, 60, 70, 75, 75);
path.cubicTo(90, 80, 110, 85, 110, 105);
path.cubicTo(110, 125, 95, 130, 80, 130);
path.cubicTo(65, 130, 50, 125, 50, 105);
path.cubicTo(50, 100, 55, 95, 60, 95);
path.cubicTo(65, 95, 70, 100, 70, 105);
path.cubicTo(70, 115, 75, 115, 80, 115);
path.cubicTo(85, 115, 90, 115, 90, 105);
path.cubicTo(90, 95, 70, 90, 55, 85);
path.cubicTo(40, 80, 20, 75, 20, 45);
path.cubicTo(20, 15, 45, 5, 70, 5);
path.cubicTo(95, 5, 120, 15, 120, 45);
path.cubicTo(120, 50, 115, 55, 110, 55);
path.cubicTo(105, 55, 100, 50, 100, 45);
path.close();`;
                        break;
                    case 'T':
                        pathCode = `// Vertical of T
path.moveTo(70, 30);
path.cubicTo(75, 25, 80, 25, 85, 30);
path.lineTo(85, 120);
path.cubicTo(85, 125, 80, 130, 75, 130);
path.cubicTo(70, 130, 65, 125, 65, 120);
path.lineTo(65, 40);
path.cubicTo(65, 35, 68, 32, 70, 30);
path.close();

// Top bar of T
path.moveTo(35, 30);
path.lineTo(115, 30);
path.cubicTo(120, 30, 125, 35, 125, 40);
path.cubicTo(125, 45, 120, 50, 115, 50);
path.lineTo(35, 50);
path.cubicTo(30, 50, 25, 45, 25, 40);
path.cubicTo(25, 35, 30, 30, 35, 30);
path.close();`;
                        break;
                    case 'U':
                        pathCode = `// Left stem of U
path.moveTo(30, 30);
path.cubicTo(35, 25, 40, 25, 45, 30);
path.lineTo(45, 90);
path.cubicTo(45, 110, 60, 120, 75, 120);
path.cubicTo(90, 120, 105, 110, 105, 90);
path.lineTo(105, 30);
path.cubicTo(105, 25, 110, 20, 115, 20);
path.cubicTo(120, 20, 125, 25, 125, 30);
path.lineTo(125, 90);
path.cubicTo(125, 120, 100, 140, 75, 140);
path.cubicTo(50, 140, 25, 120, 25, 90);
path.lineTo(25, 30);
path.close();`;
                        break;
                    case 'V':
                        pathCode = `// V shape
path.moveTo(30, 30);
path.cubicTo(35, 25, 45, 25, 50, 30);
path.lineTo(75, 110);
path.lineTo(100, 30);
path.cubicTo(105, 25, 115, 25, 120, 30);
path.cubicTo(125, 35, 125, 45, 120, 50);
path.lineTo(85, 130);
path.cubicTo(80, 135, 70, 135, 65, 130);
path.lineTo(30, 50);
path.cubicTo(25, 45, 25, 35, 30, 30);
path.close();`;
                        break;
                    case 'W':
                        pathCode = `// W shape
path.moveTo(20, 30);
path.cubicTo(25, 25, 35, 25, 40, 30);
path.lineTo(55, 100);
path.lineTo(75, 40);
path.cubicTo(77, 35, 83, 35, 85, 40);
path.lineTo(105, 100);
path.lineTo(120, 30);
path.cubicTo(125, 25, 135, 25, 140, 30);
path.cubicTo(145, 35, 145, 45, 140, 50);
path.lineTo(115, 130);
path.cubicTo(112, 135, 103, 135, 100, 130);
path.lineTo(80, 70);
path.lineTo(60, 130);
path.cubicTo(57, 135, 48, 135, 45, 130);
path.lineTo(20, 50);
path.cubicTo(15, 45, 15, 35, 20, 30);
path.close();`;
                        break;
                    case 'X':
                        pathCode = `// First diagonal of X
path.moveTo(30, 30);
path.cubicTo(35, 25, 45, 25, 50, 30);
path.lineTo(120, 120);
path.cubicTo(125, 125, 125, 135, 120, 140);
path.cubicTo(115, 145, 105, 145, 100, 140);
path.lineTo(30, 50);
path.cubicTo(25, 45, 25, 35, 30, 30);
path.close();

// Second diagonal of X
path.moveTo(120, 30);
path.cubicTo(125, 25, 135, 25, 140, 30);
path.cubicTo(145, 35, 145, 45, 140, 50);
path.lineTo(70, 140);
path.cubicTo(65, 145, 55, 145, 50, 140);
path.cubicTo(45, 135, 45, 125, 50, 120);
path.lineTo(120, 30);
path.close();`;
                        break;
                    case 'Y':
                        pathCode = `// Y shape
path.moveTo(30, 30);
path.cubicTo(35, 25, 45, 25, 50, 30);
path.lineTo(75, 80);
path.lineTo(100, 30);
path.cubicTo(105, 25, 115, 25, 120, 30);
path.cubicTo(125, 35, 125, 45, 120, 50);
path.lineTo(85, 100);
path.lineTo(85, 120);
path.cubicTo(85, 125, 80, 130, 75, 130);
path.cubicTo(70, 130, 65, 125, 65, 120);
path.lineTo(65, 100);
path.lineTo(30, 50);
path.cubicTo(25, 45, 25, 35, 30, 30);
path.close();`;
                        break;
                    case 'Z':
                        pathCode = `// Top bar of Z
path.moveTo(30, 30);
path.lineTo(120, 30);
path.cubicTo(125, 30, 130, 35, 130, 40);
path.cubicTo(130, 45, 125, 50, 120, 50);
path.lineTo(60, 50);

// Diagonal stroke
path.lineTo(120, 110);

// Bottom bar of Z
path.lineTo(30, 110);
path.cubicTo(25, 110, 20, 115, 20, 120);
path.cubicTo(20, 125, 25, 130, 30, 130);
path.lineTo(120, 130);
path.cubicTo(125, 130, 130, 125, 130, 120);
path.cubicTo(130, 115, 125, 110, 120, 110);
path.close();`;
                        break;
                    case '1':
                        pathCode = `// Number 1
path.moveTo(60, 30);
path.lineTo(75, 25);
path.cubicTo(80, 23, 85, 25, 85, 30);
path.lineTo(85, 120);
path.cubicTo(85, 125, 80, 130, 75, 130);
path.cubicTo(70, 130, 65, 125, 65, 120);
path.lineTo(65, 40);
path.lineTo(55, 45);
path.cubicTo(50, 47, 45, 45, 45, 40);
path.cubicTo(45, 35, 50, 32, 60, 30);
path.close();

// Base of 1
path.moveTo(45, 120);
path.lineTo(105, 120);
path.cubicTo(110, 120, 115, 125, 115, 130);
path.lineTo(35, 130);
path.cubicTo(30, 130, 30, 120, 35, 120);
path.lineTo(45, 120);
path.close();`;
                        break;
                    case '2':
                        pathCode = `// Number 2
path.moveTo(30, 50);
path.cubicTo(30, 35, 40, 25, 65, 25);
path.cubicTo(90, 25, 100, 40, 100, 55);
path.cubicTo(100, 75, 80, 85, 65, 95);
path.lineTo(45, 110);
path.lineTo(100, 110);
path.cubicTo(105, 110, 110, 115, 110, 120);
path.cubicTo(110, 125, 105, 130, 100, 130);
path.lineTo(30, 130);
path.cubicTo(25, 130, 20, 125, 20, 120);
path.cubicTo(20, 115, 25, 110, 35, 100);
path.lineTo(60, 80);
path.cubicTo(80, 65, 85, 60, 85, 50);
path.cubicTo(85, 40, 75, 35, 65, 35);
path.cubicTo(50, 35, 45, 45, 45, 50);
path.cubicTo(45, 55, 40, 60, 35, 60);
path.cubicTo(30, 60, 30, 55, 30, 50);
path.close();`;
                        break;
                    case '3':
                        pathCode = `// Number 3
path.moveTo(30, 40);
path.cubicTo(30, 30, 45, 20, 65, 20);
path.cubicTo(85, 20, 100, 30, 100, 45);
path.cubicTo(100, 60, 90, 70, 75, 75);
path.cubicTo(90, 80, 100, 90, 100, 105);
path.cubicTo(100, 120, 85, 130, 65, 130);
path.cubicTo(45, 130, 30, 120, 30, 110);
path.cubicTo(30, 105, 35, 100, 40, 100);
path.cubicTo(45, 100, 50, 105, 50, 110);
path.cubicTo(50, 115, 55, 120, 65, 120);
path.cubicTo(75, 120, 80, 115, 80, 105);
path.cubicTo(80, 95, 75, 85, 60, 85);
path.lineTo(55, 85);
path.cubicTo(50, 85, 45, 80, 45, 75);
path.cubicTo(45, 70, 50, 65, 55, 65);
path.lineTo(60, 65);
path.cubicTo(75, 65, 80, 55, 80, 45);
path.cubicTo(80, 35, 75, 30, 65, 30);
path.cubicTo(55, 30, 50, 35, 50, 40);
path.cubicTo(50, 45, 45, 50, 40, 50);
path.cubicTo(35, 50, 30, 45, 30, 40);
path.close();`;
                        break;
                    case '4':
                        pathCode = `// Number 4
path.moveTo(85, 130);
path.cubicTo(80, 130, 75, 125, 75, 120);
path.lineTo(75, 100);
path.lineTo(30, 100);
path.cubicTo(25, 100, 20, 95, 20, 85);
path.lineTo(65, 20);
path.cubicTo(70, 15, 80, 15, 85, 20);
path.cubicTo(90, 25, 90, 30, 85, 35);
path.lineTo(45, 90);
path.lineTo(75, 90);
path.lineTo(75, 50);
path.cubicTo(75, 45, 80, 40, 85, 40);
path.cubicTo(90, 40, 95, 45, 95, 50);
path.lineTo(95, 120);
path.cubicTo(95, 125, 90, 130, 85, 130);
path.close();`;
                        break;
                    case '5':
                        pathCode = `// Number 5
path.moveTo(95, 30);
path.lineTo(40, 30);
path.lineTo(35, 70);
path.cubicTo(40, 65, 50, 60, 65, 60);
path.cubicTo(85, 60, 100, 75, 100, 95);
path.cubicTo(100, 115, 85, 130, 65, 130);
path.cubicTo(45, 130, 30, 115, 30, 105);
path.cubicTo(30, 100, 35, 95, 40, 95);
path.cubicTo(45, 95, 50, 100, 50, 105);
path.cubicTo(50, 110, 55, 115, 65, 115);
path.cubicTo(75, 115, 80, 105, 80, 95);
path.cubicTo(80, 85, 75, 75, 65, 75);
path.cubicTo(55, 75, 45, 80, 40, 85);
path.cubicTo(35, 90, 25, 85, 25, 80);
path.lineTo(35, 20);
path.lineTo(95, 20);
path.cubicTo(100, 20, 105, 25, 105, 30);
path.cubicTo(105, 35, 100, 40, 95, 40);
path.close();`;
                        break;
                    case '6':
                        pathCode = `// Number 6
path.moveTo(90, 40);
path.cubicTo(85, 25, 75, 20, 65, 20);
path.cubicTo(45, 20, 35, 35, 35, 75);
path.cubicTo(40, 65, 50, 60, 65, 60);
path.cubicTo(85, 60, 100, 75, 100, 95);
path.cubicTo(100, 115, 85, 130, 65, 130);
path.cubicTo(45, 130, 30, 115, 30, 95);
path.lineTo(30, 75);
path.cubicTo(30, 35, 45, 10, 65, 10);
path.cubicTo(85, 10, 100, 25, 100, 35);
path.cubicTo(100, 40, 95, 45, 90, 40);
path.close();

// Inner circle of 6
path.moveTo(65, 75);
path.cubicTo(55, 75, 45, 85, 45, 95);
path.cubicTo(45, 105, 55, 115, 65, 115);
path.cubicTo(75, 115, 85, 105, 85, 95);
path.cubicTo(85, 85, 75, 75, 65, 75);
path.close();`;
                        break;
                    case '7':
                        pathCode = `// Number 7
path.moveTo(30, 30);
path.lineTo(100, 30);
path.cubicTo(105, 30, 110, 25, 110, 20);
path.cubicTo(110, 15, 105, 10, 100, 10);
path.lineTo(30, 10);
path.cubicTo(25, 10, 20, 15, 20, 20);
path.cubicTo(20, 25, 25, 30, 30, 30);
path.lineTo(75, 30);
path.lineTo(45, 120);
path.cubicTo(45, 125, 50, 130, 55, 130);
path.cubicTo(60, 130, 65, 125, 65, 120);
path.lineTo(100, 30);
path.close();`;
                        break;
                    case '8':
                        pathCode = `// Number 8
path.moveTo(65, 70);
path.cubicTo(85, 70, 100, 85, 100, 100);
path.cubicTo(100, 115, 85, 130, 65, 130);
path.cubicTo(45, 130, 30, 115, 30, 100);
path.cubicTo(30, 85, 45, 70, 65, 70);
path.close();

path.moveTo(65, 10);
path.cubicTo(85, 10, 100, 25, 100, 40);
path.cubicTo(100, 55, 85, 70, 65, 70);
path.cubicTo(45, 70, 30, 55, 30, 40);
path.cubicTo(30, 25, 45, 10, 65, 10);
path.close();

// Inner circles
path.moveTo(65, 25);
path.cubicTo(55, 25, 45, 30, 45, 40);
path.cubicTo(45, 50, 55, 55, 65, 55);
path.cubicTo(75, 55, 85, 50, 85, 40);
path.cubicTo(85, 30, 75, 25, 65, 25);
path.close();

path.moveTo(65, 85);
path.cubicTo(55, 85, 45, 90, 45, 100);
path.cubicTo(45, 110, 55, 115, 65, 115);
path.cubicTo(75, 115, 85, 110, 85, 100);
path.cubicTo(85, 90, 75, 85, 65, 85);
path.close();`;
                        break;
                    case '9':
                        pathCode = `// Number 9
path.moveTo(65, 10);
path.cubicTo(85, 10, 100, 25, 100, 65);
path.cubicTo(100, 105, 85, 130, 65, 130);
path.cubicTo(45, 130, 30, 115, 30, 105);
path.cubicTo(30, 100, 35, 95, 40, 95);
path.cubicTo(45, 95, 50, 100, 50, 105);
path.cubicTo(50, 110, 55, 115, 65, 115);
path.cubicTo(75, 115, 85, 105, 85, 65);
path.cubicTo(80, 75, 70, 80, 55, 80);
path.cubicTo(35, 80, 20, 65, 20, 45);
path.cubicTo(20, 25, 35, 10, 65, 10);
path.close();

// Inner circle of 9
path.moveTo(65, 25);
path.cubicTo(55, 25, 45, 35, 45, 45);
path.cubicTo(45, 55, 55, 65, 65, 65);
path.cubicTo(75, 65, 85, 55, 85, 45);
path.cubicTo(85, 35, 75, 25, 65, 25);
path.close();`;
                        break;
                    case '0':
                        pathCode = `// Number 0
path.moveTo(65, 10);
path.cubicTo(85, 10, 100, 25, 100, 70);
path.cubicTo(100, 115, 85, 130, 65, 130);
path.cubicTo(45, 130, 30, 115, 30, 70);
path.cubicTo(30, 25, 45, 10, 65, 10);
path.close();

// Inner oval
path.moveTo(65, 25);
path.cubicTo(55, 25, 45, 35, 45, 70);
path.cubicTo(45, 105, 55, 115, 65, 115);
path.cubicTo(75, 115, 85, 105, 85, 70);
path.cubicTo(85, 35, 75, 25, 65, 25);
path.close();

// Diagonal line
path.moveTo(85, 40);
path.lineTo(45, 100);
path.cubicTo(42, 105, 45, 110, 50, 110);
path.cubicTo(55, 110, 58, 105, 60, 100);
path.lineTo(100, 40);
path.cubicTo(103, 35, 100, 30, 95, 30);
path.cubicTo(90, 30, 87, 35, 85, 40);
path.close();`;
                        break;
                    default:
                        // For any other character, create a simple rounded rectangle 
                        // with the character drawn inside as text
                        pathCode = `// Rounded rectangle for character "${char}"
path.moveTo(40, 30);
path.cubicTo(50, 20, 100, 20, 110, 30);
path.cubicTo(120, 40, 120, 110, 110, 120);
path.cubicTo(100, 130, 50, 130, 40, 120);
path.cubicTo(30, 110, 30, 40, 40, 30);
path.close();

// Note: Inside the preview, we'll add the actual text character
// but here we're just creating the path for the rectangle`;
                }
                
                codeArea.value = pathCode;
                executeCode();
                
                // If it's a default character not in our switch case,
                // add the character as text in the SVG preview
                if (!['A', 'B', 'C', '1', '2', 'H'].includes(char)) {
                    const svg = svgPreview.querySelector('svg');
                    if (svg) {
                        // First clear any existing text
                        const existingText = svg.querySelector('text');
                        if (existingText) {
                            existingText.remove();
                        }

                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', '75');
                        text.setAttribute('y', '85');
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('dominant-baseline', 'middle');
                        text.setAttribute('font-size', '60');
                        text.setAttribute('font-family', 'Arial, sans-serif');
                        text.setAttribute('fill', '#333');
                        text.textContent = char || '';
                        svg.appendChild(text);
                    }
                }
            }
            
            // Event listeners
            runBtn.addEventListener('click', executeCode);
            clearBtn.addEventListener('click', clearAll);
            exampleBtn.addEventListener('click', loadExample);
            generateBtn.addEventListener('click', function() {
                const inputChar = charInput.value;
                generateCharacterPath(inputChar);
            });
            charInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    const inputChar = charInput.value;
                    generateCharacterPath(inputChar);
                }
            });
            
            // Copy SVG path to clipboard
            copyBtn.addEventListener('click', async function() {
                const svgPath = svgOutput.textContent;
                if (!svgPath || svgPath.startsWith('Error:')) {
                    showCopyFeedback(this, false);
                    return;
                }

                try {
                    await navigator.clipboard.writeText(svgPath);
                    showCopyFeedback(this, true);
                } catch (err) {
                    console.error('Failed to copy:', err);
                    showCopyFeedback(this, false);
                }
            });

            // Copy Path Code to clipboard
            copyCodeBtn.addEventListener('click', async function() {
                const code = codeArea.value;
                if (!code) {
                    showCopyFeedback(this, false);
                    return;
                }

                try {
                    await navigator.clipboard.writeText(code);
                    showCopyFeedback(this, true);
                } catch (err) {
                    console.error('Failed to copy:', err);
                    showCopyFeedback(this, false);
                }
            });

            // Helper function for copy button feedback
            function showCopyFeedback(button, success = true) {
                const originalText = button.textContent;
                button.textContent = success ? 'Copied!' : 'Failed!';
                button.classList.add(success ? 'success' : 'error');
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('success', 'error');
                }, 2000);
            }

            // Theme toggle functionality
            const themeToggle = document.getElementById('theme-toggle');
            const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');
            
            // Initialize theme from local storage or system preference
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                document.documentElement.setAttribute('data-theme', savedTheme);
            } else if (prefersDarkScheme.matches) {
                document.documentElement.setAttribute('data-theme', 'dark');
            }

            themeToggle.addEventListener('click', function() {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                
                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);

                // Add animation class
                this.classList.add('theme-toggle-animate');
                setTimeout(() => this.classList.remove('theme-toggle-animate'), 300);
            });

            // Listen for system theme changes
            prefersDarkScheme.addEventListener('change', (e) => {
                if (!localStorage.getItem('theme')) {
                    document.documentElement.setAttribute('data-theme', 
                        e.matches ? 'dark' : 'light');
                }
            });

            // Load example on initial load
            loadExample();

            // Add touch/mouse control variables
            let isDragging = false;
            let startX = 0;
            let startY = 0;
            let currentX = 0;
            let currentY = 0;
            let scale = 1;
            let selectedPoint = null;
            let showPoints = true;
            
            function initializePreviewControls() {
                const preview = document.getElementById('svg-preview');
                const resetBtn = document.getElementById('reset-view');
                const toggleBtn = document.getElementById('toggle-points');
                
                // Pan functionality
                preview.addEventListener('mousedown', startDrag);
                preview.addEventListener('touchstart', startDrag, { passive: false });
                document.addEventListener('mousemove', drag, { passive: false });
                document.addEventListener('touchmove', drag, { passive: false });
                document.addEventListener('mouseup', endDrag);
                document.addEventListener('touchend', endDrag);
                
                // Zoom functionality
                preview.addEventListener('wheel', handleZoom);
                
                // Reset view
                resetBtn.addEventListener('click', resetView);
                
                // Toggle points
                toggleBtn.addEventListener('click', () => {
                    showPoints = !showPoints;
                    const points = preview.querySelectorAll('.point-handle, .control-point');
                    points.forEach(point => {
                        point.style.display = showPoints ? 'block' : 'none';
                    });
                });

                // Add double-tap to reset transform
                let lastTap = 0;
                preview.addEventListener('touchend', (e) => {
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTap;
                    if (tapLength < 500 && tapLength > 0) {
                        const pathElement = preview.querySelector('path');
                        if (pathElement) {
                            pathElement.removeAttribute('transform');
                            updateHandlePositions(pathElement);
                        }
                    }
                    lastTap = currentTime;
                });

                // Add touch event for point manipulation
                preview.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    const element = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (element && (element.classList.contains('point-handle') || 
                                  element.classList.contains('control-point'))) {
                        handlePointDrag(e);
                    }
                }, { passive: false });
            }
            
            function startDrag(e) {
                if (e.target.classList.contains('point-handle') || 
                    e.target.classList.contains('control-point') ||
                    e.target.classList.contains('transform-handle')) {
                    return; // Don't start panning if clicking on control points
                }
                e.preventDefault();
                isDragging = true;
                const point = e.touches ? e.touches[0] : e;
                startX = point.clientX - currentX;
                startY = point.clientY - currentY;
                svgPreview.classList.add('dragging');
            }
            
            function drag(e) {
                if (!isDragging) return;
                e.preventDefault();
                const point = e.touches ? e.touches[0] : e;
                
                // Add bounds checking to prevent dragging too far
                const newX = point.clientX - startX;
                const newY = point.clientY - startY;
                
                const maxDrag = 1000; // Maximum drag distance
                currentX = Math.min(Math.max(newX, -maxDrag), maxDrag);
                currentY = Math.min(Math.max(newY, -maxDrag), maxDrag);
                
                updateTransform();
            }
            
            function endDrag() {
                isDragging = false;
                svgPreview.classList.remove('dragging');
            }
            
            function handleZoom(e) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                scale *= delta;
                scale = Math.min(Math.max(0.5, scale), 3);
                updateTransform();
            }
            
            function updateTransform() {
                const svg = svgPreview.querySelector('svg');
                if (svg) {
                    svg.style.transform = `translate(${currentX}px, ${currentY}px) scale(${scale})`;
                }
            }
            
            function resetView() {
                currentX = 0;
                currentY = 0;
                scale = 1;
                updateTransform();
            }
            
            // Update the executeCode function to add interactive points
            const originalExecuteCode = executeCode;
            executeCode = function() {
                originalExecuteCode();
                
                // Make points interactive
                const points = svgPreview.querySelectorAll('circle');
                points.forEach(point => {
                    point.classList.add(point.getAttribute('fill') === '#ff0000' ? 'control-point' : 'point-handle');
                    point.addEventListener('mousedown', handlePointDrag);
                    point.addEventListener('touchstart', handlePointDrag);
                });

                const pathElement = svgPreview.querySelector('path');
                if (pathElement) {
                    initializeTransformHandles(pathElement);
                }
            };
            
            function handlePointDrag(e) {
                e.preventDefault();
                e.stopPropagation();
                selectedPoint = e.target;
                const svg = svgPreview.querySelector('svg');
                const rect = svg.getBoundingClientRect();
                let lastUpdate = 0;
                
                const updatePoint = (moveEvent) => {
                    moveEvent.preventDefault();
                    const now = Date.now();
                    const point = moveEvent.touches ? moveEvent.touches[0] : moveEvent;
                    
                    // Throttle updates for better performance
                    if (now - lastUpdate > 16) { // ~60fps
                        const x = (point.clientX - rect.left) / scale;
                        const y = (point.clientY - rect.top) / scale;
                        
                        const viewBox = svg.viewBox.baseVal;
                        const boundedX = Math.max(viewBox.x, Math.min(viewBox.x + viewBox.width, x));
                        const boundedY = Math.max(viewBox.y, Math.min(viewBox.y + viewBox.height, y));
                        
                        selectedPoint.setAttribute('cx', boundedX);
                        selectedPoint.setAttribute('cy', boundedY);
                        updateConnectedLines(selectedPoint);
                        updatePathAndCode(svg);
                        lastUpdate = now;
                    }
                };
                
                document.addEventListener('mousemove', updatePoint, { passive: false });
                document.addEventListener('touchmove', updatePoint, { passive: false });
                
                const stopDrag = () => {
                    document.removeEventListener('mousemove', updatePoint);
                    document.removeEventListener('touchmove', updatePoint);
                    selectedPoint = null;
                    updatePathAndCode(svg, true); // Final update with highlight
                };
                
                document.addEventListener('mouseup', stopDrag, { once: true });
                document.addEventListener('touchend', stopDrag, { once: true });
            }
            
            function updateConnectedLines(point) {
                const svg = svgPreview.querySelector('svg');
                const lines = svg.querySelectorAll('line');
                const x = point.getAttribute('cx');
                const y = point.getAttribute('cy');
                
                lines.forEach(line => {
                    if (line.getAttribute('x1') === point.previousX) {
                        line.setAttribute('x1', x);
                        line.setAttribute('y1', y);
                    }
                    if (line.getAttribute('x2') === point.previousX) {
                        line.setAttribute('x2', x);
                        line.setAttribute('y2', y);
                    }
                });
                
                point.previousX = x;
                point.previousY = y;
            }

            function updatePathAndCode(svg, highlight = false) {
                const points = Array.from(svg.querySelectorAll('circle'));
                const pathCommands = [];
                let currentCommand = null;
                
                // Update path element
                const pathElement = svg.querySelector('path');
                const newPathData = generatePathData(points);
                pathElement.setAttribute('d', newPathData);
                
                // Generate and update code
                const code = generatePathCode(points);
                codeArea.value = code;
                
                if (highlight) {
                    highlightCodeChanges();
                }
            }

            function generatePathData(points) {
                // Convert points to SVG path data
                let pathData = '';
                points.forEach((point, index) => {
                    const x = point.getAttribute('cx');
                    const y = point.getAttribute('cy');
                    const type = point.getAttribute('data-type');
                    
                    if (type === 'moveTo' || index === 0) {
                        pathData += `M ${x},${y} `;
                    } else {
                        pathData += `L ${x},${y} `;
                    }
                });
                return pathData;
            }

            function generatePathCode(points) {
                // Generate path code from points
                let code = '';
                points.forEach((point, index) => {
                    const x = parseFloat(point.getAttribute('cx')).toFixed(2);
                    const y = parseFloat(point.getAttribute('cy')).toFixed(2);
                    const type = point.getAttribute('data-type') || (index === 0 ? 'moveTo' : 'lineTo');
                    
                    code += `path.${type}(${x}, ${y});\n`;
                });
                return code;
            }

            function highlightCodeChanges() {
                codeArea.classList.add('highlight');
                setTimeout(() => {
                    codeArea.classList.remove('highlight');
                }, 1000);
            }

            function initializeTransformHandles(pathElement) {
                const handles = ['top-left', 'top-right', 'bottom-right', 'bottom-left'];
                const bbox = pathElement.getBBox();
                
                handles.forEach(position => {
                    const handle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    handle.setAttribute('r', '5');
                    handle.setAttribute('class', `transform-handle ${position}`);
                    handle.setAttribute('fill', '#4CAF50');
                    handle.setAttribute('stroke', '#fff');
                    handle.setAttribute('stroke-width', '2');
                    
                    // Position the handle
                    const [vertical, horizontal] = position.split('-');
                    handle.setAttribute('cx', horizontal === 'left' ? bbox.x : bbox.x + bbox.width);
                    handle.setAttribute('cy', vertical === 'top' ? bbox.y : bbox.y + bbox.height);
                    
                    // Add event listeners
                    handle.addEventListener('mousedown', startTransform);
                    handle.addEventListener('touchstart', startTransform);
                    
                    pathElement.parentNode.appendChild(handle);
                });
            }

            function startTransform(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const handle = e.target;
                const pathElement = handle.previousElementSibling;
                const bbox = pathElement.getBBox();
                const position = handle.getAttribute('class').split(' ')[1];
                
                const initialPoint = e.touches ? e.touches[0] : e;
                const startX = initialPoint.clientX;
                const startY = initialPoint.clientY;
                const startWidth = bbox.width;
                const startHeight = bbox.height;
                
                function transform(moveEvent) {
                    const currentPoint = moveEvent.touches ? moveEvent.touches[0] : moveEvent;
                    const dx = (currentPoint.clientX - startX) / scale;
                    const dy = (currentPoint.clientY - startY) / scale;
                    
                    let newWidth = startWidth;
                    let newHeight = startHeight;
                    let translateX = 0;
                    let translateY = 0;
                    
                    switch(position) {
                        case 'top-left':
                            newWidth = startWidth - dx;
                            newHeight = startHeight - dy;
                            translateX = dx;
                            translateY = dy;
                            break;
                        case 'top-right':
                            newWidth = startWidth + dx;
                            newHeight = startHeight - dy;
                            translateY = dy;
                            break;
                        case 'bottom-right':
                            newWidth = startWidth + dx;
                            newHeight = startHeight + dy;
                            break;
                        case 'bottom-left':
                            newWidth = startWidth - dx;
                            newHeight = startHeight + dy;
                            translateX = dx;
                            break;
                    }
                    
                    // Update path dimensions and position
                    const scaleX = newWidth / startWidth;
                    const scaleY = newHeight / startHeight;
                    const transform = `translate(${translateX},${translateY}) scale(${scaleX},${scaleY})`;
                    pathElement.setAttribute('transform', transform);
                    
                    // Update handle positions
                    updateHandlePositions(pathElement);
                }
                
                function endTransform() {
                    document.removeEventListener('mousemove', transform);
                    document.removeEventListener('touchmove', transform);
                }
                
                document.addEventListener('mousemove', transform);
                document.addEventListener('touchmove', transform);
                document.addEventListener('mouseup', endTransform, { once: true });
                document.addEventListener('touchend', endTransform, { once: true });
            }
            
            function updateHandlePositions(pathElement) {
                const bbox = pathElement.getBBox();
                const handles = pathElement.parentNode.querySelectorAll('.transform-handle');
                
                handles.forEach(handle => {
                    const position = handle.getAttribute('class').split(' ')[1];
                    const [vertical, horizontal] = position.split('-');
                    
                    handle.setAttribute('cx', horizontal === 'left' ? bbox.x : bbox.x + bbox.width);
                    handle.setAttribute('cy', vertical === 'top' ? bbox.y : bbox.y + bbox.height);
                });
            }
            
            // Initialize preview controls
            initializePreviewControls();

            // Improve theme toggle accessibility
            themeToggle.setAttribute('role', 'button');
            themeToggle.setAttribute('aria-label', 'Toggle theme');
            themeToggle.setAttribute('tabindex', '0');
            themeToggle.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    themeToggle.click();
                }
            });
        });
    </script>
</body>
</html>
